---
title: "Extinction simulation on the metaweb"
author: AD 
date: \today
output:
  bookdown::pdf_document2:
    toc: true
---


```{r, echo = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  echo = FALSE,
  collapse = TRUE,
  comment = "#>",
  #fig.dim = c(7, 7),
  fig.fullwidth = TRUE,
  fig.asp = .5, 
  fig.show = "hold",
  message = FALSE,
  warning = FALSE,
  results = TRUE
)
```
```{r, echo = FALSE, results = FALSE}
library(drake)
library(ggformula)
library(INLA)
mypath <- rprojroot::find_package_root_file
source(mypath("R/misc.R"))
source(mypath("R/variable_shortcut.R")) # Define your custom code as a bunch of functions.
source_dir(get_mypath("R")) # Define your custom code as a bunch of functions.

mytheme <- theme_cowplot() +
background_grid()

theme_set(mytheme)
```

```{r}
loadd(full_data2, basin_station)
colnames(full_data2)


data_inla <- full_data2 %>%
  left_join(basin_station, by = "station") %>%
      mutate(
        station = as.character(station),
        basin = as.character(basin),
        basin1 = as.character(basin),
        station1 = as.character(station),
        intercept_basin = as.integer(as.factor(basin)),
        intercept_basin_station = as.integer(as.factor(paste0("basin", basin, ":", "station", station)))
        )
```
```{r}
facet_var <- c(get_biomass_var(), get_com_str_var())
gaussian_inla_no_drivers <- tibble(
  response = facet_var,
  mod = purrr::map(facet_var, ~try(inla(
        formula = get_formula_inla(resp = .x, tau_prior = FALSE),
        control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE,
              return.marginals=TRUE, return.marginals.predictor=TRUE),
        control.predictor = list(link = 1, compute = T),
        verbose = F,
        data = data_inla
        ))))
save(gaussian_inla_no_drivers, file = mypath("data", "gaussian_inla_no_drivers.rda"))
```

```{r}
gaussian_inla_no_drivers_effects <-
  format_inla_model_list(x = gaussian_inla_no_drivers)
glob_tps_trends_decade_no_drivers <-
  gaussian_inla_no_drivers_effects %>%
  filter(term == "nb_year") %>%
  mutate(
    mean = map2_dbl(response, mean,
      ~compute_trends_meaningful_units(x = .y, resp = .x,
        time = 10)),
    low = map2_dbl(response, low,
      ~compute_trends_meaningful_units(x = .y, resp = .x),
      time = 10),
    high = map2_dbl(response, high,
      ~compute_trends_meaningful_units(x = .y, resp = .x),
      time = 10)
  )
```


```{r}
gaussian_pred_station_tps <- gaussian_inla_no_drivers %>%
  mutate(
    station_tps = map(mod, ~get_re_prediction_inla(.x, effect = "station1"))
  ) %>%
select(-mod) %>%
unnest(station_tps)

gaussian_pred_station_tps10  <- gaussian_pred_station_tps %>%
  mutate(
    mean = map2_dbl(response, mean,
      ~compute_trends_meaningful_units(x = .y, resp = .x,
        time = 10)),
    quant0.025 = map2_dbl(response, quant0.025,
      ~compute_trends_meaningful_units(x = .y, resp = .x),
      time = 10),
    quant0.975 = map2_dbl(response, quant0.975,
      ~compute_trends_meaningful_units(x = .y, resp = .x),
      time = 10)
  )
tps_for_sem <- gaussian_pred_station_tps10 %>%
  select(response, station, mean, sd) %>%
  pivot_wider(everything(), names_from = "response", values_from = c("mean", "sd"))
```

```{r}
library(semEff)
library(piecewiseSEM)
```

```{r}
sem <- list(
  lm(mean_ct_ff ~ mean_log_bm_std + mean_log_rich_std, data = tps_for_sem,
    weight = 1 / (sd_log_rich_std + sd_log_bm_std + sd_ct_ff)),
    lm(mean_w_trph_lvl_avg ~ mean_log_bm_std + mean_log_rich_std, data = tps_for_sem,
      weight = 1 / (sd_log_rich_std + sd_log_bm_std + sd_w_trph_lvl_avg)),
      lm(mean_log_bm_std ~ mean_log_rich_std, data = tps_for_sem,
        weight = 1 / (sd_log_rich_std + sd_log_bm_std)
        )
)
plot(as.psem(sem))
rsquared(sem)
```

```{r}
semeff_perc_inla <- semEff(sem, R = 1000, seed = 13, parallel = "no",
  ci.type = "perc"
)
save(semeff_perc_inla, file = get_mypath("data", "semeff_perc_inla.rda"))
```

```{r}
loadd(environment_pca)
sp_for_sem <- data_inla %>%
  group_by(station) %>%
  summarise(across(facet_var, median))

basin_station <- data_inla %>%
  select(c(station, basin)) %>%
  group_by(station) %>%
  summarise(across(c("basin"), unique))

sp_for_sem <- sp_for_sem %>%
  left_join(environment_pca %>%
    mutate(station = as.character(station)) %>%
    select(c(station, log_RC1, log_RC2)),
    by = "station") %>%
  left_join(basin_station, by = "station")
```

```{r}
sp_sem <- list(
     log_rich_std = lmer(log_rich_std ~ log_RC1 + log_RC2 + (1 | basin), data = sp_for_sem),
     log_bm_std = lmer(log_bm_std ~ log_rich_std + log_RC1 + log_RC2 + (1 | basin), data = sp_for_sem),
     ct_ff = lmer(ct_ff ~ log_rich_std + log_bm_std + log_RC1 + log_RC2 + (1 | basin), data = sp_for_sem),
     w_trph_lvl_avg = lmer(w_trph_lvl_avg ~ log_rich_std + log_bm_std + log_RC1 + log_RC2 +
       (1 | basin), data = sp_for_sem)
)
sp_psem <- as.psem(sp_sem)
summary_sp_sem <- summary(sp_psem)
plot(sp_psem,
  node_attrs = data.frame(
    shape = "rectangle", fixedsize = TRUE, width = .8, color = "black",
    fillcolor = "lightgrey", nodesep = 2))
rsquared(sp_psem)
```

```{r}
sp_semeff_perc <- semEff(sp_sem, R = 1000, seed = 13, parallel = "no",
  ci.type = "perc", ran.eff = "basin"
)
save(sp_semeff_perc, file = get_mypath("data", "sp_semeff_perc.rda"))
```

## Model performance

```{r}
gaussian_inla_rand <- gaussian_inla_no_drivers %>%
  mutate(
        hpd_random = map(
          mod,
          ~get_hpdmarginal_inla(
            inla_mod = .x,
            type = "rand"
          )
        )
        ) %>%
      select(-mod) %>%
      unnest(hpd_random)
```

```{r}
gaussian_inla_var_fitted <- gaussian_inla_no_drivers %>%
      mutate(
        var_pred = furrr::future_map(mod, function(y) {
          map_dbl(y$marginals.fitted.values,
            ~var(inla.rmarginal(100, .x))
          )
        }
          )
      ) %>%
    select(-mod)
```

```{r}
r2_inla <- gaussian_inla_var_fitted %>%
      left_join(get_std_inla_from_rand(inla_rand_tab = gaussian_inla_rand), by = "response") %>%
      mutate(
        r2_mvp_marg = pmap(
          list(var_pred, intercept_basin, intercept_basin_station, epsilon),
          ~r2_mvp(var_pred = ..1, std_intercept = c(..2, ..3), epsilon = ..4, type = "marginal")
          ),
        r2_mvp_cond = pmap(
          list(var_pred, intercept_basin, intercept_basin_station, epsilon),
          ~r2_mvp(var_pred = ..1, std_intercept = c(..2, ..3), epsilon = ..4, type = "conditional")
          ),
        r2_mvp_marg_mean = map_dbl(r2_mvp_marg, mean),
        r2_mvp_marg_med = map_dbl(r2_mvp_marg, median),
        r2_mvp_marg_sd = map_dbl(r2_mvp_marg, sd),
        r2_mvp_cond_mean = map_dbl(r2_mvp_cond, mean),
        r2_mvp_cond_med = map_dbl(r2_mvp_cond, median),
        r2_mvp_cond_sd = map_dbl(r2_mvp_cond, sd),
        lab_r2_marg = paste0("~~~~R^2 == ", round(r2_mvp_marg_med, 2)),
        lab_r2_cond = paste0("~~~~R^2 == ", round(r2_mvp_cond_med, 2)),
        r2_mvp_marg95hpd = map(r2_mvp_marg, ~coda::HPDinterval(coda::as.mcmc(.x))),
        r2_mvp_marg95hpdci = map2_chr(r2_mvp_marg95hpd, r2_mvp_marg_mean,
          ~paste0(
            format(round(.y, 2), nsmall = 2),
            " [",
            format(round(.x[, "lower"], 2), nsmall = 2),
            ",",
            format(round(.x[, "upper"], 2), nsmall = 2),
            "]")
          ),
        r2_mvp_cond95hpd = map(r2_mvp_cond, ~coda::HPDinterval(coda::as.mcmc(.x))),
        r2_mvp_cond95hpdci = map2_chr(r2_mvp_cond95hpd, r2_mvp_cond_mean,
          ~paste0(
            format(round(.y, 2), nsmall = 2),
            " [",
            format(round(.x[, "lower"], 2), nsmall = 2),
            ",",
            format(round(.x[, "upper"], 2), nsmall = 2),
            "]")
          ),
      )
r2_inla %>%
  select(response, r2_mvp_marg95hpdci, r2_mvp_cond95hpdci)
```

```{r}
r2_sem <- rbind(
  rsquared(sp_psem) %>%
  select(Response, Marginal, Conditional) %>%
  mutate(type = "spatial"),
rsquared(sem) %>%
  mutate(Marginal = R.squared, Conditional = NA, type = "temporal") %>%
  select(Response, Marginal, Conditional, type)
)
 
```






#' Get species from nodes
#' @param list 
#'
#' @details By convention the node naming scheme is set as the following:
#'  species_code + _ + class_nb. This function is just a wrapper around
#'  extract_all().
#'
get_species <- function(node_list) {

  species_resource_list <- stringr::str_extract_all(
    node_list, "[A-Za-z]+", simplify = TRUE)

  species_resource_list

}

#' Colours species 
#'
#'  
#' @inheritParams set_layout_graph a object generated by build_metaweb
#'
#' @return a colour scale 
set_color_species <- function (node_list = NULL, species_list = NULL,  resource_list = NULL,
  col_resource = NULL) {
  # Extract species
  if (is.null(species_list)) {
    sp_list <- stringr::str_extract_all(
      node_list, "[A-Z]+", simplify = TRUE) %>%
    as.vector %>%
    unique
    sp_list <- sp_list[sp_list != ""]
  } else {
    regex_pattern <- paste0(species_list, collapse = "|")
    sp_list <- stringr::str_extract_all(
      node_list, regex_pattern, simplify = TRUE) %>%
    as.vector %>%
    unique
    # Remove empty names
    sp_list <- sp_list[sp_list != ""]
  }
  # get hue color
  gg_color_hue <- function(n) {
    hues = seq(0, 360, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  species_color <- gg_color_hue(length(sp_list))
  names(species_color) <- sp_list

  #Resource:
  if (is.null(resource_list)) {
    resource_list <- stringr::str_extract_all(
      node_list, "[a-z]+", simplify = TRUE) %>%
    as.vector %>%
    unique
    # Remove empty names
    resource_list <- resource_list[resource_list != ""]
  }
  if (is.null(col_resource)) {
    col_resource <- "#CCCCCC"
  }
  resource_color <- rep(col_resource, length(resource_list))
  names(resource_color) <- resource_list
  c(species_color, resource_color)
}
my_crap_temporal_network <- function (
  net = NULL,
  metaweb = parent.frame()$meta$metaweb,
  network_data = parent.frame()$network_analysis,
  bm_var = "biomass",
  my_y_lim = NULL,
  color_node = NULL,
  ...) {

  # Get network list
  net_list <- net %>%
    dplyr::select(date, from, to) %>%
    arrange(date) %>%
    group_by(date) %>%
    nest(.key = "network")

  # Get biomass
  size_analysis <- network_data %>%
      dplyr::select(opcod, composition) %>%
      filter(opcod %in% net$opcod) %>%
      unnest()

    if ("species" %in% names(size_analysis)) {
      sp_var <- "species"
    } else {
      sp_var <- "sp_class"
    }

    bm_var_sym <- sym(bm_var)
    sp_var_sym <- sym(sp_var)

    size_analysis %<>%
      left_join(dplyr::select(net, date, opcod) %>%
	distinct(opcod, date)) %>%
    dplyr::select(date, !!bm_var_sym, !!sp_var_sym) %>%
    arrange(date) %>%
    group_by(date) %>%
    nest() %>%
    mutate(!!bm_var_sym := map(data,
	function(x){
	val <- x[[bm_var]]
	names(val) <- x[[sp_var]]
	val
	}
	)
    )

  net_list %<>%
    left_join(dplyr::select(size_analysis, date, !!bm_var_sym))

  #Get the nodes of the network:
  node <- net_list$network %>% unlist(., use.names = FALSE) %>% unique

  metaweb <- igraph::graph_from_adjacency_matrix(metaweb) %>% 
    igraph::as_data_frame(.) %>%
    #mutate_all(list(~str_extract_all(., "[a-zA-Z]+", simplify = TRUE))) %>%
    distinct(from, to)

  # Get the unique species (add for sp_class)
  species <- unique(str_extract(c(metaweb[[1]], metaweb[[2]]), "[A-Z]{3}"))

  # Get constant x position for the nodes  
  ## Get a layout:
  layout <- ggraph::create_layout(
    igraph::graph_from_data_frame(metaweb),
    layout = "kk")
  node_position <- layout$x
  names(node_position) <- layout$name

  #color of the nodes:
  if (!is.null(color_node)) {
    color <- set_color_species(
      node_list = node,
      species_list = NULL,
      resource_list = NULL,
      col_resource = NULL)
  }

  #Â Trophic level 
  net_list %<>%
    mutate(
      network_graph = map(network, igraph::graph_from_data_frame,
	directed = TRUE),
      network_graph = map(network_graph, igraph::as_adjacency_matrix,
	sparse = FALSE),
      troph = map(network_graph, ~NetIndices::TrophInd(.x)),
      obs_troph_level_vector = map(troph, function (x) {
	out <- x$TL
	names(out) <- rownames(x)
	return(out)
	}
      )
    ) %>%
  dplyr::select(-troph)

  out <- plot_temporal_network(
    data = net_list,
    net_var = network,
    date = date,
    x = node_position,
    y = net_list[["obs_troph_level_vector"]],
    size = net_list[[bm_var]],
    color = color,
    ...
  )

  out$plots[[1]] <- out$plots[[1]] +
    labs(y = "Trophic level") +
    theme(
      axis.line.y = element_line(),
      axis.ticks.y = element_line(),
      axis.text.y = element_text(),
      axis.title.y = element_text(),
    )

    out$legends <- cowplot::get_legend(
      out$plots[[1]] +
	scale_color_manual(values = out$color, limits = names(out$color)) +
	labs(colour = "Species", size = "Biomass") +
	guides(
	  colour = guide_legend(
	    label.position = "left",
	    ncol = 4,
	    byrow = TRUE,
	    title.position = "top"),
	  size = guide_legend(
	    nrow = 1,
	    byrow = TRUE,
	    title.position = "top"
	  )
	  ) +
	theme(
	  plot.margin = unit(c(0, 0, 0, 0), "cm"),
	  legend.direction = "horizontal", 
	  legend.position = "bottom",
	  legend.box = "vertical",
	  legend.margin = margin(t = 0, b = 0, l = 0, r = 0),
	  legend.spacing.x = unit(.1, 'cm'),
	  legend.spacing.y = unit(.1, 'cm'),
	  text = element_text(size = 8),
	  legend.text = element_text(
	    size = NULL,
	    margin = margin(r = 5)
	  )
	)
    )
    out$plots <- map(out$plots, function (x) {
      x + theme(legend.position = "none",
	plot.margin = unit(c(0, 0, 0, 0), "cm"), 
	axis.title.x = element_text()
      )
    }) 

    if (!is.null(my_y_lim)) {
    out$plots <- map(out$plots, function (x) {
      x + ylim(my_y_lim) 
    })
    }

    return(out)
}

#' Temporal graph for a station
#'
#' @param net data.frame contaning date variable and network list
#' @param meta an object created by build_metaweb
#' @param dead character vector indicating which node are basal
#' @param x named vector of node x position
#' @param y list of named vector of node vertical position
#' @param ... optional parameters for set_layout_graph  
#' @return a plot_grid object 
#' @seealso set_layout_graph
#' 
plot_temporal_network <- function(data = NULL,
  net_var = NULL,
  date = NULL,
  y = NULL,
  x = NULL,
  size = NULL,
  color = NULL,
  ncol_graph = NULL,
  nrow_sp_legend = NULL,
  return_data = FALSE,
  ...){

  net_var <- rlang::enquo(net_var)
  net_var_chr <- rlang::quo_name(net_var)
  date_var <- rlang::enquo(date)
  date_var_chr <- rlang::quo_name(date_var)

  if (is.null(color)) {
  # Get species_resource list
  species_resource_list <- purrr::map(data[[net_var_chr]], function(net) {
    if (any(class(net) == "data.frame")) {
      net <- igraph::graph_from_data_frame(net, directed = TRUE)
    } else if (any(class(net) == "matrix")) {
      net <- igraph::graph_from_adjacency_matrix(net, mode = "directed")
    } else {
      stopifnot(any(class(net) == "igraph"))
    }
    attr(igraph::V(net), "name")
      }) %>%
  unlist(., use.names = FALSE) %>%
  unique
  color <- set_color_species(species_resource_list)
  }

  for (i in 1:nrow(data)) {
    data[[net_var_chr]][[i]] <- set_layout_graph(
      net = data[[net_var_chr]][[i]],
      y = y[[i]],
      title = data[[date_var_chr]][[i]],
      biomass = size[[i]],
      x = x,
      color_scale = color
    )
  }
  if (is.null(nrow_sp_legend)) {
    nrow_sp_legend <- 3
  }

  species_colour_legend <- cowplot::get_legend(
    data[[net_var_chr]][[1]] +
      scale_color_manual(values = color, limits = names(color)) +
      labs(colour = "Species", size = "Biomass") +
      guides(
	colour = guide_legend(nrow = nrow_sp_legend, byrow = TRUE,
	  title.position = "left"),
	size = guide_legend(nrow = 1, byrow = TRUE, title.position = "left")
	) +
      theme(legend.direction = "vertical", 
	legend.position = "bottom",
	legend.box = "horizontal")
  )

  if (return_data) {
    out <- list(
      plots = data[[net_var_chr]],
      legends = species_colour_legend,
      color = color 
    )
   return(out) 
  }

  ## Remove legend in the other plots
  data %<>%
    mutate(
      !!net_var := map(!!net_var, function (x) {
    x + theme(legend.position = "none",
      plot.margin = unit(c(0, 0, 0, 0), "cm"))
    })
    )


  if (is.null(ncol_graph)) {
    ncol_graph <- 5 
  }

  p <- cowplot::plot_grid(plotlist = data[[net_var_chr]], ncol = ncol_graph)
  cowplot::plot_grid(p, species_colour_legend, nrow = 2, rel_heights = c(1, 0.2))
}

#' Generate ggraph with a common layout
#'
#'  
#' @param net: data.frame describing edges 
#' @param glay a layout objet created by create_layout
#' @param title chr
#'
#' @return a ggraph object
set_layout_graph <- function (
  net = NULL, glay = NULL,
  x = NULL, y = NULL, title = NULL,
  biomass = NULL, color_scale= NULL,
  dead_material = NULL) {

  if (any(class(net) == "data.frame")) {
    net <- igraph::graph_from_data_frame(net, directed = TRUE)
  } else if (any(class(net) == "matrix")) {
    net <- igraph::graph_from_adjacency_matrix(net, mode = "directed")
  } else {
    stopifnot(class(net) == "igraph")
  }

  if (is.null(glay)) {
    # for species network:
    llay <- ggraph::create_layout(net, layout = "kk")
    node_pos <- NetIndices::TrophInd(igraph::as_adjacency_matrix(net, sparse = FALSE), Dead = dead_material)$TL - 1
    llay$y <- node_pos
    llay$species <- get_species(llay$name)
  } else {
    # get node coord from the general:
    node_names <- attr(V(net), "name")
    coord <- filter(glay, name %in% node_names) %>%
      mutate(name = as.character(name))
    # local layout:
    llay <- ggraph::create_layout(net, layout = "kk")
    saved_graph <- attr(llay, "graph")
    saved_circular_attr <- attr(llay, "circular")
    saved_class <- class(llay)
    llay <- select(llay, -x, -y) %>%
      mutate(name = as.character(name)) %>%
      left_join(., coord, by = "name") %>%
      select(x, y, everything())
    attr(llay, "graph") <- saved_graph
    attr(llay, "circular") <- saved_circular_attr
    class(llay) <- saved_class
  }

  node_names <- as.character(llay$name)
  if (!is.null(y)) {

    ## sp to change values:
    mask_y <- names(y) %in%  node_names
    mask_sp <- node_names %in% names(y)
    sp_to_change <- node_names[mask_sp]
    y_to_change <- y[mask_y]
    ## Reorder the two vector
    llay$y[mask_sp][order(factor(sp_to_change))] <- y_to_change[order(factor(names(y_to_change)))]
  }
  if (!is.null(x)) {
    stopifnot(!any(is.null(names(x))))
    x <- x[names(x) %in% node_names]
    llay$x[order(factor(node_names))] <- x[order(factor(names(x)))]
  }
  if (!is.null(color_scale)) {
    if (any(!node_names %in% names(color_scale))) {
      missing_color <- node_names[!node_names %in% names(color_scale)]
      cat("The following nodes do not have defined color: ",
	  missing_color, "They have been replaced by gray color.\n")
      color_to_add <- rep("#CCCCCC", length(missing_color))
      names(color_to_add) <- missing_color
      color_scale <- c(color_scale, color_to_add)
    }
  }
  p <- ggraph::ggraph(llay) +
    ggraph::geom_edge_fan(color = "grey80", alpha = .3, strength = .5, show.legend = FALSE) +
    coord_cartesian(ylim=c(1,4.5))
  if (!is.null(biomass)) {
    stopifnot(all(names(biomass) %in% node_names))
    dataset <- p$data
    biomass <- biomass[names(biomass) %in% node_names]
    mask_sp <- dataset$name %in% names(biomass)

    dataset$biomass <- numeric(nrow(dataset))
    dataset$biomass[mask_sp][order(factor(dataset$name[mask_sp]))] <-
      biomass[order(factor(names(biomass)))]
    dataset$biomass[!mask_sp] <- .01 

  }
  if (!is.null(title)) {
    p <- p + labs(x = title)
  }
  p <- p + ggraph::theme_graph(
    foreground     = NULL,
    fg_text_colour = "white",
    base_family    = "sans",
    background     = NA,
    title_size = 11,
    title_face = "bold",
    title_margin = 0
  )
  if (!is.null(color_scale) & !is.null(biomass)) {
    p <- p +
      ggraph::geom_node_point(data = dataset, aes(x = x, y = y, size = biomass,
	  color = species)) +
      scale_color_manual(values = color_scale, limits = names(color_scale))
  } else if (!is.null(color_scale) & is.null(biomass)) {
    p <- p +
      ggraph::geom_node_point(aes(color = species)) +
      scale_color_manual(values = color_scale, limits = names(color_scale))
  } else if (is.null(color_scale) & is.null(biomass)) {
    p <- p +
      ggraph::geom_node_point()
  } else if (is.null(color_scale) & !is.null(biomass)) {
    p <- p +
      ggraph::geom_node_point(data = dataset,
	aes(x = x, y = y, size = biomass))
  }
  p

}

#' Personal plot theme
#'
#' @details This theme was design from the theme developped in the hrbrthemes
#' package: https://github.com/hrbrmstr/hrbrthemes 
#' @return a ggplot theme
theme_alain <- function(){

  hrbrthemes::theme_ipsum_rc() +
  theme(#Whipe
    text = element_text(family = "Helvetica", hjust = .5),
    axis.title = element_text(family = "Helvetica", hjust = .5, face = "bold", size = 10),
    plot.title = NULL,
    axis.title.x = NULL,
    axis.title.y = NULL,
    axis.text.x = NULL,
    axis.text.y = NULL,
    strip.text = NULL) +
  theme(#Set up
    plot.title = element_text(family = "Helvetica", hjust = .5, face = "bold", size = 10),
    axis.title.y = element_text(angle = 90, face = "bold"),
    axis.title.x = element_text(face = "bold"),
    axis.text = element_text(size = 8),
    strip.text = element_text(size = 8),
    plot.margin = unit(c(.5, .5, .5, .5), "cm")
    )
}
xylabs <- function (...) {
  dots <- pryr::named_dots(...)
  dots <- map(dots, eval) %>% unlist

  lab_list <- list(
    del = expression(bold(paste("Fraction of global dispersal (", delta, ")"))),
    biomass_cv = paste("CV of biomass"),
    biomass_stab = paste("Stability of Biomass"),
    biomass_avg = paste("Average biomass (g)"),
    network_med = paste("Median of network metrics"),
    nbnode = paste("Number of nodes"),
    richness = paste("Species richness"),
    richness_cv = paste("CV of richness"),
    richness_avg = paste("Average richness"),
    richness_avg = paste("Median richness"),
    connectance = paste("Connectance"),
    connectance_avg = paste("Average connectance"),
    connectance_med = paste("Median connectance"),
    connectance_cv = paste("CV of connectance"),
    diversity = paste("Diversity")
    )
  
  lab_used <- lab_list[dots]
  names(lab_used) <- names(dots)

  labs(
    x = lab_used["x"][[1]],
    y = lab_used["y"][[1]]
    )
}

#' Plot dynamic of biomass by station
#'
#' @param sync data.frame e.g. synchrony dataset, output from get_sync_cv_mat()
#' @param station id of station
#' @param trophic_level data.frame from data folder with trophic level and
#' trophic class derived from the metaweb
#' @param .log logical transform biomass in log (e.g. log10())
plot_dyn_sp_biomass <- function (sync = NULL, station = NULL, trophic_level = NULL, .log = FALSE) {

  sync <- sync[sync$station == station, ] 

  .data <- sync$com_mat_date[[1]] %>%
    gather(key = species, value = biomass, -date) %>%
    left_join(trophic_level, by = "species")

  main_title <- paste0("Stab = ", round(1/(sync$cv_com), 2),", ", "Sync = ",
    round(sync$synchrony, 2),", ", "CVsp = ", round(sync$cv_sp, 2))
  
  p <- .data %>%
    mutate(label = if_else(date == max(date), as.character(species), NA_character_)) %>%
  ggplot(aes(x = date, y = biomass, colour = species)) + 
  geom_line(aes(linetype = as.factor(troph_group))) + 
  labs(y = "Biomass (g)", x = "Sampling date",
  title = main_title, subtitle = paste0("Station: ", station)) +
  ggrepel::geom_label_repel(aes(label = label),
    size = 2.5, nudge_x = 1, na.rm = TRUE)

  troph_grp_scale <- c("1" = "dotted", "2" = "dashed", "3" = "solid")
  p <- p + scale_linetype_manual(values = troph_grp_scale)

  if (.log) {
    p <- p + scale_y_log10() 
  }

  return(p)
}

plot_temporal_biomass <- function (bm_data = NULL, biomass_var = NULL, com = NULL, .log = FALSE) {

  #main_title <- paste0("Stab = ", round(1/(sync$cv_com), 2),", ", "Sync = ",
    #round(sync$synchrony, 2),", ", "CVsp = ", round(sync$cv_sp, 2))
  sym_bm_var <- rlang::sym(biomass_var)
  # Total
  total_biomass <- bm_data %>% 
  group_by(date) %>%
  summarise(!!sym_bm_var := sum(!!sym_bm_var, na.rm = FALSE))
  
  p <- bm_data %>%
    mutate(label = if_else(date == max(date), as.character(species), NA_character_)) %>%
  ggplot(aes_string(x = "date", y = biomass_var, color = "species")) + 
  geom_line() +
  lims(y = c(0, max(total_biomass[[biomass_var]]))) +
  labs(
  #title = main_title, subtitle = paste0("Station: ", station),
    y = "Biomass (g)", x = "Sampling date"
  ) +
  ggrepel::geom_label_repel(aes(label = label),
    size = 2.5, nudge_x = 1, na.rm = TRUE) 
  
  #Â Add total biomass
  p2 <- p +
    geom_line(data = total_biomass, aes(color = "black", size = 3)) +
    theme(legend.position = "none")

  # Add summary: richness, connectance, stab, t_lvl, sync, cv_sp 
  com %<>%
    mutate_if(is.double, round(., 2))

  label <- paste(
    "S = ", com$bm_std_stab,
    "sync = ", com$sync,
    "CVsp = ", com$cv_sp,
    "R = ", com$rich_tot_std,
    "C = ", com$ct,
    "Tlvl = ", com$t_lvl
  ) 

  p3 <- p2 +
    annotate("text", x = median(total_biomass$date),
      y = 15, label = label)

  if (.log) {
    p3 <- p3 + scale_y_log10() 
  }

  return(p3)
}

###############
#  Labellers  #
###############

mylabel <- function() {
  ggplot2::as_labeller(c(
    connectance = "Connectance",
    connectance_corrected_med = "Median connectance",
    connectance_corrected = "Connectance (corrected)",
    richness = "Species richness",
    max_troph_level = "Highest trophic level",
    mean_troph_level = "Average trophic level",
    mean_troph_level = "Average trophic level",
    mean_troph_level_corrected = "Average trophic level (corrected)",
    mean_troph_level_med = "Median average trophic level",
    mean_troph_level_corrected_med = "Median average trophic level",
    w_troph_lvl_corrected = "Weighted average trophic level (corrected)",
    w_troph_lvl = "Weighted average trophic level",
    modularity = "Modularity",
    modularity_corrected = "Modularity corrected",
    nestedness = "Nestedness",
    nbnode = "Number of nodes",
    nbnode_med = "Median number of nodes",
    richness_cv = "richness CV",
    richness_avg = "Average richness",
    richness_med = "Median richness",
    betadiv = "Beta-diversity",
    synchrony = "Synchrony",
    cv_sp = "Avg species CV",
    biomass_stab = "Biomass stability (1/CV)"
    #betadiv = expression(bold(paste(beta, "-diversity", sep = "")))
    #see https://stackoverflow.com/questions/35524202/as-labeller-with-expression-in-ggplot2-facet-wrap?rq=1
      )
    )
}

#' Troph group labeller
#' Returns a labeller for ggplot2
#' @param troph_class a object created by get_size_class function
#' @return a labeller for ggplot2
troph_group_labeller <- function (troph_class = NULL, round_lvl = 2) {

  if (is.null(troph_class)) {
    myload(trophic_class, dir = mypath("data"))
    troph_class <- trophic_class
  }
  troph_class %<>%
    dplyr::mutate(
      lower = paste("[", round(lower, round_lvl), sep = ""),
      upper = paste(round(upper, round_lvl), "]", sep = "")
      ) %>%
  tidyr::unite(bounds, lower, upper, sep = ";") %>%
  dplyr::rename(troph_group = class_id)

  bounds <- troph_class$bounds
  names(bounds) <- troph_class$troph_group
  as_labeller(bounds)

}


###############
#  plot SEMs  #
###############
ggsem <- function(fit, layout = "sugiyama") {

  # Extract standardized parameters
  params <- lavaan::standardizedSolution(fit)

  # Edge properties
  param_edges <- params %>% 
    filter(op %in% c("=~", "~", "~~"), lhs != rhs, pvalue < .05) %>%
    transmute(to = lhs,
              from = rhs,
              val = est.std,
              type = dplyr::case_when(
                op == "=~" ~ "loading",
                op == "~"  ~ "regression",
                op == "~~" ~ "correlation",
                TRUE ~ NA_character_))

  # Identify latent variables for nodes
  latent_nodes <- param_edges %>% 
    filter(type == "loading") %>% 
    distinct(to) %>% 
    transmute(metric = to, latent = TRUE)

  # Node properties
  param_nodes <- params %>% 
    filter(lhs == rhs) %>% 
    transmute(metric = lhs, e = est.std) %>% 
    left_join(latent_nodes) %>% 
    mutate(latent = if_else(is.na(latent), FALSE, latent))

  # Complete Graph Object
  param_graph <- tidygraph::tbl_graph(param_nodes, param_edges)

  # Plot
  ggraph(param_graph, layout = layout) +
    # Latent factor Nodes
    geom_node_point(aes(alpha = as.numeric(latent)),
                                     shape = 16, size = 5) +
    geom_node_point(aes(alpha = as.numeric(latent)),
                                     shape = 16, size = 4, color = "white") +
    # Observed Nodes
    geom_node_point(aes(alpha = as.numeric(!latent)),
                                     shape = 15, size = 5) +
    geom_node_point(aes(alpha = as.numeric(!latent)),
                                     shape = 15, size = 4, color = "white") +
    # Regression Paths (and text)
    geom_edge_link(aes(color = val, label = round(val, 2),
                       alpha = as.numeric(type == "regression")),
                   linetype = 1, angle_calc = "along", vjust = -.5,
                   arrow = arrow(20, unit(.3, "cm"), type = "closed")) +
    # Factor Loadings (no text)
    geom_edge_link(aes(color = val, alpha = as.numeric(type == "loading")),
                   linetype = 3, angle_calc = "along",
                   arrow = arrow(20, unit(.3, "cm"), ends = "first", type = "closed")) +
    # Correlation Paths (no text)
    geom_edge_link(aes(color = val, alpha = as.numeric(type == "correlation")),
                   linetype = 2, angle_calc = "along",
                   arrow = arrow(20, unit(.3, "cm"), type = "closed", ends = "both")) +
    # Node names
    geom_node_text(aes(label = metric),
                   nudge_y = .25, hjust = "inward") +
    # Node residual error
    geom_node_text(aes(label = sprintf("%.2f", e)),
                   nudge_y = -.1, size = 3) +
    # Scales and themes
    scale_alpha(guide = FALSE, range = c(0, 1)) +
    scale_edge_alpha(guide = FALSE, range = c(0, 1)) +
    scale_edge_colour_gradient2(guide = FALSE, low = "red", mid = "darkgray", high = "green") +
    scale_edge_linetype(guide = FALSE) +
    scale_size(guide = FALSE) +
    theme_graph()
}

ggpiecewisesem <- function(fit, layout = "sugiyama", p_val_thd = .05) {

  # Extract standardized parameters
  params <- fit$coefficients
  colnames(params) <- str_to_lower(colnames(params))
  colnames(params)[length(colnames(params))] <- "stars" 

  # Edge properties
  param_edges <- params %>%
    filter(p.value < p_val_thd) %>%
    transmute(to = as.character(response),
              from = as.character(predictor),
              val = std.estimate) %>%
    mutate(type = "regression")

  # Identify latent variables for nodes
  #latent_nodes <- param_edges %>% 
    #filter(type == "loading") %>% 
    #distinct(to) %>% 
    #transmute(metric = to, latent = TRUE)

  # Node properties
  param_nodes <- tibble(
    metric = as.character(unique(unlist(params[,c("response", "predictor")]))),
      latent = FALSE,
      e = 0
  ) 

  param_graph <- tidygraph::tbl_graph(nodes = param_nodes, edges = param_edges)

  # Plot
  ggraph(param_graph, layout = layout) +
    # Latent factor Nodes
    geom_node_point(aes(alpha = as.numeric(latent)),
                                     shape = 16, size = 5) +
    geom_node_point(aes(alpha = as.numeric(latent)),
                                     shape = 16, size = 4, color = "white") +
    # Observed Nodes
    geom_node_point(aes(alpha = as.numeric(!latent)),
                                     shape = 15, size = 5) +
    geom_node_point(aes(alpha = as.numeric(!latent)),
                                     shape = 15, size = 4, color = "white") +
    # Regression Paths (and text)
    geom_edge_link(aes(color = val, label = round(val, 2),
                       alpha = as.numeric(type == "regression")),
                   linetype = 1, angle_calc = "along", vjust = -.5,
                   arrow = arrow(20, unit(.3, "cm"), type = "closed")) +
    # Factor Loadings (no text)
    geom_edge_link(aes(color = val, alpha = as.numeric(type == "loading")),
                   linetype = 3, angle_calc = "along",
                   arrow = arrow(20, unit(.3, "cm"), ends = "first", type = "closed")) +
    # Correlation Paths (no text)
    geom_edge_link(aes(color = val, alpha = as.numeric(type == "correlation")),
                   linetype = 2, angle_calc = "along",
                   arrow = arrow(20, unit(.3, "cm"), type = "closed", ends = "both")) +
    # Node names
    geom_node_text(aes(label = metric),
                   nudge_y = .25, hjust = "inward") +
    # Node residual error
    geom_node_text(aes(label = sprintf("%.2f", e)),
                   nudge_y = -.1, size = 3) +
    # Scales and themes
    scale_alpha(guide = FALSE, range = c(0, 1)) +
    scale_edge_alpha(guide = FALSE, range = c(0, 1)) +
    scale_edge_colour_gradient2(guide = FALSE, low = "red", mid = "darkgray", high = "green") +
    scale_edge_linetype(guide = FALSE) +
    scale_size(guide = FALSE) +
    theme_graph()
}

build_diag_from_sem <- function (
  fit = NULL,
  p_val_thd = NULL,
  env_x_pos_range = c(from = 0, to = 3),
  env_y_pos = 0,
  env_y_sep = 1,
  order_env_node = NULL,
  metamodel = FALSE,
  inverse_y_node_pose = FALSE
  ) {

  est <- fit$coefficients
  names(est)[9] <- "stars"

  rsq <- fit$R2

  # Replace names
  node_name_replacement <- c(
    "log_RC1" = "PCA1 \n Avg \n stream size",
    "log_RC2" = "PCA2 \n Avg \n temperature",
    "log_RC3" = "CV flow \n & \n Avg enrichment",
    "RC4" = "CV \n stream size",
    "RC5" = "CV \n enrichment",
    "ct" = "Connectance",
    "t_lvl" = "Avg \n trophic level",
    "log_cv_sp" = "CVsp",
    "log_sync" = "Synchrony",
    "log_stab_std" = "Biomass \n stability",
    "log_stab" = "Biomass \n stability",
    "log_rich_tot_std" = "Species \n richness",
    "log_rich_tot" = "Species \n richness",
    "log_bm_std" = "Total \n biomass",
    "log_bm" = "Total \n biomass"
  )

  # Put Rsquared:
  var_with_rsq <- c("ct", "t_lvl", "log_cv_sp",
    "log_sync", "log_rich_tot", "log_rich_tot_std", "log_stab",
    "log_stab_std", "log_bm", "log_bm_std")
  var_with_rsq <- var_with_rsq[var_with_rsq %in% rsq$Response]

  if (!metamodel) {
  node_name_replacement[names(node_name_replacement) %in% var_with_rsq] <-
    map_chr(names(node_name_replacement)[names(node_name_replacement) %in% var_with_rsq],
      function(x, rsq, node_name) {
	paste0(node_name[x], "\n", "Rsq = ", rsq[rsq$Response == x,]$Marginal)
      }, rsq = rsq, node_name = node_name_replacement)
  }
  # Get node
  node_set <- est %>%
    dplyr::select(Response, Predictor) %>%
    tidyr::gather(type, nodes, Response, Predictor) %>%
    dplyr::select(nodes) %>%
    dplyr::distinct() 

  ## Set node type 
  type_of_node <- vector(mode = "list", length = 6)
  names(type_of_node)         <- c("evt", "rich", "com", "stab_comp", "stab", "bm")
  type_of_node[["evt"]]       <- c(paste0("log_RC", seq(1,3)), paste0("RC", seq(4,5)))
  type_of_node[["rich"]]      <- paste0("log_rich_tot", c("", "_std"))
  type_of_node[["com"]]       <- c("ct", "t_lvl")
  type_of_node[["stab_comp"]] <- c("log_sync", "log_cv_sp")
  type_of_node[["stab"]]      <- paste0("log_stab", c("", "_std"))
  type_of_node[["bm"]]        <- paste0("log_bm", c("", "_std"))

  node_set %<>%
    mutate(
      type = map_chr(nodes, function (x) {
	if (any(type_of_node[["evt"]] %in% x)) {
	  type <- "evt" 
	} else if (x %in% type_of_node[["rich"]]) {
	  type <- "rich"
	} else if (any(x %in% type_of_node[["stab_comp"]])) {
	  type <- "stab_comp"
	} else if (any(x %in% type_of_node[["com"]])) {
	  type <- "com"
	} else if (x %in% type_of_node[["stab"]]) {
	  type <- "stab" 
	} else if (x %in% type_of_node[["bm"]]) {
	  type <- "bm" 
	}
	return(type)
		       })
    )
  # Set node shape:
  #evt_node <- str_match(node_set$nodes, "RC")[, 1]
  #node_shape <- ifelse(!is.na(evt_node), "circle", "box")

  node_df <- create_node_df(
    n = nrow(node_set),
    label = node_set$nodes,
    shape = "box",
    style = "solid",
    color = "black", 
    fontcolor = "black", 
    type = node_set$type,
    width = 1,
    height = 1
  )
  #https://rich-iannone.github.io/DiagrammeR/graph_creation.html
  # Order env nodes
  if (!is.null(order_env_node)) {

    node_label_in_env <- which(node_df$label %in% type_of_node[["evt"]])
    env_node_pos_in_df <- map_int(order_env_node, ~which(node_df$label == .x))

    node_df[node_label_in_env, ] <-
      node_df[env_node_pos_in_df, ]
  }
   
  # Set node placement

  ##Â Mask
  evt_node_mask <- node_df$label %in% type_of_node[["evt"]]
  rich_node_mask <- node_df$label %in% type_of_node[["rich"]]
  com_node_mask <- node_df$label %in%  type_of_node[["com"]]

  # Pos
  env_x_pos <- seq(
    from = env_x_pos_range["from"],
    to = env_x_pos_range["to"],
    length.out = length(which(evt_node_mask))
  )

  mid_pos <- (max(env_x_pos) - min(env_x_pos)) / 2

  node_df$x <- NA
  node_df$x[evt_node_mask] <- env_x_pos
  node_df$x[rich_node_mask] <- mid_pos 
  node_df$x[com_node_mask]  <- env_x_pos[c(1,2)]

  node_df$y <- NA

  if (inverse_y_node_pose) {
    node_df$y[evt_node_mask]  <- env_y_pos
    node_df$y[rich_node_mask] <- env_y_pos + env_y_sep
    node_df$y[com_node_mask]  <- env_y_pos + 2 * env_y_sep
  } else {
    node_df$y[evt_node_mask]  <- env_y_pos
    node_df$y[rich_node_mask] <- env_y_pos - env_y_sep
    node_df$y[com_node_mask]  <- env_y_pos - 2 * env_y_sep
  }

  #Â Adapt if SEM is for stab or bm:
  if (any(node_df$label %in% type_of_node[["stab"]])) {

    node_df$x[node_df$label %in% type_of_node[["stab_comp"]] ] <- env_x_pos[c(1, 2)]
    node_df$x[node_df$label %in% type_of_node[["stab"]] ]      <- mid_pos

    if (inverse_y_node_pose) {
      node_df$y[node_df$label %in%  type_of_node[["stab_comp"]] ] <- env_y_pos + 3 * env_y_sep
      node_df$y[node_df$label %in%  type_of_node[["stab"]] ]      <- env_y_pos + 4 * env_y_sep
    } else {
      node_df$y[node_df$label %in%  type_of_node[["stab_comp"]] ] <- env_y_pos - 3 * env_y_sep
      node_df$y[node_df$label %in%  type_of_node[["stab"]] ]      <- env_y_pos - 4 * env_y_sep
    }
    
  } else if (any(node_df$label %in% type_of_node[["bm"]])) {

    node_df$x[node_df$label %in% type_of_node[["bm"]] ]  <- mid_pos 

    if (inverse_y_node_pose) {
      node_df$y[node_df$label %in%  type_of_node[["bm"]] ] <- env_y_pos + 3 * env_y_sep
    } else {
      node_df$y[node_df$label %in%  type_of_node[["bm"]] ] <- env_y_pos - 3 * env_y_sep
    }
    
  } else {
    stop("SEM has no stability or total biomass. Function cannot set node position.")
  }

  # Replace label to have nice label names 
  current_node_label_replacement <-
  node_name_replacement[names(node_name_replacement) %in% node_df$label]
  node_df$label <- str_replace_all(node_df$label, current_node_label_replacement)

  replace_edge <- as.character(node_df$id)
  # Order node set occording to order_env_node (already taken in account in
  # node_df$id):
  names(replace_edge) <- node_set[node_df$id, ]$nodes

  # Get path
  all_path <- est %>%
    dplyr::mutate(
      edge_from = str_replace_all(Predictor, replace_edge),
      edge_to = str_replace_all(Response, replace_edge),
      rel = round(Std.Estimate, 2)
      )

    
  ## Select significant path
  if (!is.null(p_val_thd) & !metamodel) {
    all_path %<>% dplyr::filter(P.Value < p_val_thd)
  }
  
  ## Metamodel mode: 
  if (metamodel) {
    myrep <- function (x) rep(x, times = nrow(all_path)) 
    penwidth <- myrep(1) 
    color <- myrep("black")  
    label <- myrep("")
  } else {
    penwidth <- abs(all_path$rel)*5
    color <- ifelse(all_path$rel < 0, "red", "green")
    label <- as.character(all_path$rel)
  }

  edge_df <- create_edge_df(
    from = all_path$edge_from, 
    to = all_path$edge_to, 
    penwidth = penwidth,
    color = color,  
    rel = as.character(all_path$rel),
    label = label,
    fontsize = 12 
  )

  graph <- DiagrammeR::create_graph(
    nodes_df = node_df,
    attr_theme = "default",
    edges_df = edge_df
  )
  # Create spline shape: https://github.com/rich-iannone/DiagrammeR/issues/215

  return(graph)
} 

export_diagram <- function (
  fit = NULL,
  format = "png",
  width = 700*2,
  height = 900*2  - 900*2*30/100,
  file_path = NULL,
  arrows = "ortho",
  val_thd = 0.05,
  env_x_pos_range = c(from = 0, to = 7.5),
  env_y_pos = 0,
  env_y_sep = 1.5,
  order_env_node = c("RC4", "log_RC3", "RC5", "log_RC1", "log_RC2"),  
  metamodel = FALSE,
  inverse_y_node_pose = FALSE
  ) {


  file_path <- paste0(file_path, ".", format) 

  graph <- build_diag_from_sem(
    fit = fit, 
    p_val_thd = val_thd,
    env_x_pos_range = env_x_pos_range,
    env_y_pos = env_y_pos,
    env_y_sep = env_y_sep,
    order_env_node = order_env_node,  
    metamodel = metamodel, 
    inverse_y_node_pose = inverse_y_node_pose
  )
  graph %<>%
    add_global_graph_attrs(
      attr = "splines",
      value = arrows, #spline
      attr_type = "graph")

  render_graph(graph)
  export_graph(
    graph = graph,
    file_type = format,
    file_name = file_path,
    height = height,
    width = width
  )

  #Â Get the plot as an R object
  img <- file_path %>%
    magick::image_read()
  p_sem <- cowplot::ggdraw() +
    cowplot::draw_image(img)
  return(p_sem)

}

###################
#  Plot response  #
###################

#' Make the plot for troph
#' @param .data output from compute_stat_troph_rich()
make_troph_plot <- function (
  .data = NULL,
  resp  = NULL,
  x_lim = NULL,
  y_lim = NULL,
  lab_xy = NULL,
  rsq_xy = NULL
  )  {


  resp_sym <- sym(resp)

  # data:
  raw_data <- .data[["all"]] %>%
    dplyr::select(troph_group, data) %>%
    tidyr::unnest(data)

  # Basic plot:
  p <- na.omit(raw_data) %>%
    ggplot(
      aes(
	x     = log_rich_tot_std,
	y     = !!resp_sym,
	color = troph_group
      )
      ) +
    geom_point()

  # Add model prediction:
  prediction <- .data[["predict"]]
  p <- p + 
    geom_line(data = prediction) +
    geom_ribbon(
      data = prediction,
      aes(
	ymin  = conf.low,
	ymax  = conf.high,
	color = NULL,
	group = troph_group
	),
      alpha = .2
    )

    # Custom colors:
    p <- p +
      ggplot2::scale_color_manual(
	labels = troph_group_labeller(),
	values = c("blue", "green", "red"),
	name   = "Trophic group"
      )

    # Add Rsq of the model:
    rsq_data <- .data[["rsq"]]
    p <- p + 
    annotate(
      "text",
      x     = rsq_xy["x"],
      y     = rsq_xy["y"],
      label = make_label_rsq(rsq = rsq_data[1,]),
      parse = TRUE,
      color = "blue",
      hjust = 0,
      vjust = 1
      ) +
    annotate(
      "text",
      x     = rsq_xy["x"],
      y     = rsq_xy["y"],
      label = make_label_rsq(rsq = rsq_data[2,]),
      parse = TRUE,
      color = "green",
      hjust = 0,
      vjust = 0
    )

    # Set axis limit:
    if (!all(map_lgl(list(x_lim, y_lim), ~is.null(.x)))) {
      p <- p +
	ylim(y_lim) +
	xlim(x_lim)
    }

    if (!is.null(lab_xy)) {
      p <- p + 
	labs(x = lab_xy["x"], y = lab_xy["y"])
    }

    return(p)
    
}



##############
#  PCA plot  #
##############
my_pca_plot <- function (.data = pca_rotated$rotated, xaxis = NULL, yaxis = NULL, ctb_thld = .4) {

  pca_data <- .data$loadings[1:nrow(.data$loadings),]
  pca_data %<>%
    as_tibble() %>%
    mutate(variable = row.names(pca_data),
      variable = str_replace_all(variable, get_pca_var_name_replacement())
    )
 pca_label <- filter(pca_data, abs(.data[[xaxis]]) > ctb_thld | abs(.data[[yaxis]]) > ctb_thld) 


 var_exp <- round(.data$Vaccounted["Proportion Var",]* 100)

ggplot() +
  ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1),
    inherit.aes = FALSE
  ) +
  geom_segment(
    data = tibble(
      x = c(-1, 0), xend = c(1, 0),
      y = c(0, -1), yend = c(0, 1)
      ),
    aes(x = x, y = y, xend = xend, yend = yend),
    size = .25
  ) +
  xlim(-1, 1) +
  ylim(-1, 1) +
  labs(
    x = paste0(xaxis, " (",var_exp[xaxis], "%)"),
    y = paste0(yaxis, " (",var_exp[yaxis], "%)")
    ) +
  geom_segment(data = pca_data, aes_string(x = 0, y = 0, xend = xaxis, yend = yaxis),
    arrow = arrow(angle = 20, length = unit(0.05, "inches"),
           ends = "last", type = "open"),
	 size = .25
  ) +
  ggrepel::geom_label_repel(data = pca_label,
    aes_string(x = xaxis, y = yaxis, label = "variable"),
    size = 2, force = 10, box.padding = .1, label.padding = .1
  )
}

################################################################################
#                                 Plot labels                                  #
################################################################################

#' Make label for Rsq
#'
#' @param rsq output from piecewieseSEM::rsquared
#'
make_label_rsq <- function(rsq = NULL) {

  rsq_cond <- round(rsq$Conditional, 2)
  rsq_marg <- round(rsq$Marginal, 2)

  tmp <- "paste(
  \"Marg. \",  italic(R) ^ 2, \" = \", marg, \", \",
  \"Cond. \", italic(R) ^ 2, \" = \", cond 
  )"
  
  str_replace_all(tmp, c(
      "cond" = as.character(rsq_cond),
      "marg" = as.character(rsq_marg))
  )
}


get_min_max <- function (l, var_chr) {

  vec <- purrr::map(l, ~.x[[var_chr]]) %>% unlist
  c(min = min(vec, na.rm = TRUE), max = max(vec, na.rm =TRUE))
  }


#' Theme for maps
#' https://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only/
theme_map <- function(...) {
  theme_minimal() +
  theme(
    text = element_text(family = "Ubuntu Regular", color = "#22211d"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # panel.grid.minor = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.major = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    panel.border = element_blank(),
    ...
  )
}

get_sem_var_name_replacement <- function () {
  out <- c(

    "log_RC1" = "PCA1 \n Avg \n stream size",
    "log_RC2" = "PCA2 \n Avg \n temperature",
    "log_RC3" = "CV flow \n & \n Avg enrichment",
    "RC4" = "CV \n enrichment",
    "RC5" = "CV flow \n & \n Avg enrichment",
    "ct" = "Connectance",
    "t_lvl" = "Avg \n trophic level",
    "log_cv_sp" = "CVsp",
    "log_sync" = "Synchrony",
    "log_stab_std" = "Biomass \n stability",
    "log_stab" = "Biomass \n stability",
    "log_rich_tot_std" = "Species \n richness",
    "log_rich_tot" = "Species \n richness",
    "log_bm_std" = "Total \n biomass",
    "log_bm" = "Total \n biomass"
  )
  return(out)
}

get_pca_var_name_replacement <- function () {

  out <- c(
    "slope" = "Slope",
    "alt" = "Altitude",
    "d_source" = "Distance from source",
    "strahler" = "Strahler order",
    "width_river_mean" = "Avg stream width",
    "avg_depth_station_mean" = "Avg stream depth",
    "width_river_cv" = "CV stream width",
    "avg_depth_station_cv" = "CV stream depth",
    "DBO_med" = "Avg BOD",
    "flow_med" = "Avg flow",
    "temperature_med" = "Avg temperature",
    "DBO_cv" = "CV BOD",
    "flow_cv" = "CV flow",
    "temperature_cv" = "CV temperature"
  )

  return(out)

}

##################
#  Format table  #
##################

format_table <- function (x = tmp_stab_indir_table) {
  x <- x[, c("variable", names(x)[!names(x) %in% "variable"])]

  rm_n <- str_remove_all(get_sem_var_name_replacement(), pattern = "\n ")
  names(rm_n) <- names(get_sem_var_name_replacement()) 
  x$variable <- str_replace_all(x$variable, rm_n)

  #colnames(x) %<>% str_remove_all(., pattern = "via_")

  col_replacement <- c(
    direct = "Direct",
    variable = "Variable",
    via_cv_sp = "CVsp",
    via_sync = "Synchrony",
    #richness_com = "Species richness and network structure",
    via_richness = "Species richness",
    via_ct = "Connectance",
    via_tlvl = "Avg trophic level",
    via_com = "Network structure",
    `_` = " and ",
    total = "Total effect"
  )
  colnames(x) %<>% str_replace_all(., col_replacement)

  x
}

plot_sensivity_analysis <- function (.data = NULL, y_lim = c(-1.26, .75), inverse_label_order = FALSE) {
  .data %<>%
    mutate(
      r_p = str_c(response, predictor, sep = " ~ "),
      r_p = str_replace_all(r_p, get_sem_var_name_replacement()),
      r_p = str_remove_all(r_p, pattern = "\n ")
      ) 
  
  if (inverse_label_order) {
    .data$r_p <- factor(
      .data$r_p,
      levels = unique(.data$r_p))
    #sizes <- factor(sizes, levels=rev(levels(sizes)))
    p <- .data %>%
      ggplot(aes(x = factor(r_p, levels = rev(levels(r_p))),
	  y = std.estimate)) 
  } else {
    p <- .data %>%
      ggplot(aes(x = r_p, y = std.estimate)) 
  }

  p +
    labs(x = "Terms of the linear models",
      y = "Standardized estimate", color = "Dataset type") +
    ylim(y_lim) +
    geom_point(aes(color = dataset)) +
    scale_color_hue(labels = c(
	"Constant (N=99)", "Constant / Without holes (N=65)",
	"Complete (N=403)", "Without holes (N=275)")
      ) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1))
}

---
title: "Report"
author: "Alain Danet"
output: html_document
---

```{r}
knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>",
  #fig.dim = c(7, 7),
  fig.fullwidth = TRUE,
  fig.show = "hold",
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = TRUE 
)

library(drake)
library(tidyverse)
library(magrittr)
library(cowplot)
library(viridis)
source("R/misc.R") # Define your custom code as a bunch of functions.
source_dir(get_mypath("R")) # Define your custom code as a bunch of functions.

#theme_set(theme_cowplot())
```

# Research questions

## State of the art

- Report of community biomass (or number of individual) collapses in many
  ecosystems
- Modification of community are linked to modification in network structure 
- Studies have been interested in how network assembles or disassembles
  themselves.
- However, the lack of availability of such empirical dataset have prevented the
answering to this question.  
  
- Questions:
  1. Is a decrease or a increase in biomass related to a network
     structure modification?
     1.1 Is a contant decrease/increase in biomass correspond the same dynamic
     in network? Or there are non linear dynamics ?
  2. Are assembly and disassembly of networks symmetric processes?


# Results


## Links betwenn temporal dynamics

```{r}
loadd(net_dyn_lm)
loadd(net_dyn_lm_plot)
```


```{r b-bivar-cap}
bivar_cap <- paste0(
  "Links between temporal dynamics of biomass and temporal dynamics of
  metrics for the communities which have a median biomass across time inferior
  to the median of the station (little) and the other (big)"
)
```


```{r p-bivar, cache = TRUE, fig.cap = bivar_cap, fig.height = 10}

cowplot::plot_grid(
  cowplot::plot_grid(plotlist = net_dyn_lm_plot$plot[1:4], ncol = 2),
  cowplot::plot_grid(plotlist = filter(net_dyn_lm_plot, group == "big")$plot[1:4], ncol = 2),
  ncol = 1, 
  axis = "rlbt",
  align = "hv",
  label_y = 1.01,
  label_x = .40,
  labels = c("Little community", "Big community")
)
 
cowplot::plot_grid(
  cowplot::plot_grid(plotlist = net_dyn_lm_plot$plot[5:8], ncol = 2),
  cowplot::plot_grid(plotlist = filter(net_dyn_lm_plot, group == "big")$plot[5:8], ncol = 2),
  ncol = 1, 
  axis = "rlbt",
  align = "hv",
  label_y = 1.01,
  label_x = .40,
  labels = c("Little community", "Big community")
)
```

- Intercept close to 0 for all but richness in big communities 
- Same slope between big and little communities except for connectance 


```{r}
loadd(temporal_dynamics_coef)
loadd(temporal_dynamics_plot)
loadd(full_data2)
loadd(biomass_group)
```


```{r}
temporal_dynamics_coef %>%
  filter(term %in% "slope", coeff %in% c("bm_std", "log_bm_std")) %>%
  select(1:4) %>%
  pivot_wider(names_from = "term", values_from = estimate) %>%
  left_join(biomass_group, by = c("station", "coeff" = "bm_var")) %>%
  filter(group_type == "median", summary_type %in% c("first_3_year", "median")) %>%
  ggplot(aes(x = bm, y = slope)) +
  geom_point(aes(color = group)) +
  facet_wrap(coeff~summary_type, scales = "free") +
  labs(x = "Summary of biomass (g)", y = "Slope (g.y^-1)")
```

```{r}
full_data2 %>%
  group_by(station) %>%
  summarise(med_bm = median(biomass)) %>%
  ggplot(aes(x = med_bm)) +
  geom_histogram() +
  labs(x = "Median total biomass over time by station (g)")
```

##

```{r, eval = FALSE}
slope_com_net <- temporal_dynamics_coef %>%
  filter(!coeff %in% get_biomass_var(), term == "slope") %>%
  select(station, coeff, estimate) %>%
  pivot_wider(names_from = "coeff", values_from = estimate)

absolute_slope_biomass <- temporal_dynamics_coef %>%
  filter(coeff %in% get_biomass_var(), term == "slope") %>%
  select(station, coeff, estimate) %>%
  mutate(
    absolute_slope =  abs(estimate),
    trend_sign = if_else(estimate > 0, "positive", "negative")
  ) %>%
  left_join(slope_com_net, by = "station") 

metrics <- unique(temporal_dynamics_coef$coeff)[!unique(temporal_dynamics_coef$coeff) %in% get_biomass_var()]

p <- vector("list", length = length(metrics))
for (i in seq_along(metrics)) {
  p[[i]] <- 
    absolute_slope_biomass %>%
    ggplot(aes_string(x = "absolute_slope", y = metrics[i])) +
    geom_point(aes(color = trend_sign)) +
    facet_wrap(facets = ~ coeff, scales = "free") +
    labs(title = metrics[i])
}
p
```



# Methods

## Biomass classification

```{r}
loadd(rigal_classification)
myload(biomass_ts_sax, envir = globalenv(),dir = get_mypath("data"))

biomass_classif_rigal <- rigal_classification %>%
  filter(variable %in% c("bm_std", "log_bm_std")) %>%
  unnest(classif) %>%
  mutate(station = as.character(station)) %>%
  select(station, variable,shape_class)

p_biomass_classif_rigal <- biomass_classif_rigal %>%
  ggplot(aes(x = shape_class)) +
  geom_bar() +
  facet_wrap(~variable) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Temporal dynamics

```{r}
p_cap <- paste0(
  "Temporal dynamics of biomass and temporal dynamics of
  metrics for 10 randomly selected communities."
)
```

```{r p-tmp-dyn, cache = TRUE}

p <- vector(mode = "list", length = 10)
for (i in seq_len(length(p))) {
  to_plot <- temporal_dynamics_plot %>% 
    filter(station == sample(temporal_dynamics_plot$station, 1))
  p[[i]] <- cowplot::plot_grid(plotlist = to_plot$plot, labels = to_plot$station)
}
p
```


## Temporal dynamics decrease/increase constant

### Log biomass

```{r, fig.height = 45}
st_decrease_increase_rigal <- biomass_classif_rigal %>%
  filter(variable == "log_bm_std") %>%
  filter(shape_class %in% c("increase_constant", "decrease_constant"))
data_decrease_increase <- full_data2 %>%
  filter(station %in% st_decrease_increase_rigal$station)

log_bm_min_max <- map_dbl(c(min, max),
  ~.x(data_decrease_increase$log_bm, na.rm = TRUE))
nb_year_min_max <- map_dbl(c(min, max),
  ~.x(data_decrease_increase$nb_year, na.rm = TRUE))
temporal_dynamics_plot$plot %<>%
  map(., ~ .x + lims(y = log_bm_min_max, x = nb_year_min_max))

temporal_dynamics_plot %>%
  filter(variable == "bm_std", station %in% st_decrease_increase_rigal$station) %>%
  plot_grid(plotlist = .$plot, ncol = 3, labels = st_decrease_increase_rigal$station)
```

### Raw Biomass

```{r, fig.height = 45}
st_decrease_increase_rigal_biomass <- rigal_classification %>%
  filter(variable == "bm_std") %>%
  unnest(classif) %>%
  filter(shape_class %in% c("increase_constant", "decrease_constant"))

bm_min_max <- map_dbl(
  c(min, max),
  ~.x(data_decrease_increase$biomass, na.rm = TRUE))
nb_year_min_max <- map_dbl(
  c(min, max),
  ~.x(data_decrease_increase$nb_year, na.rm = TRUE))
temporal_dynamics_plot[temporal_dynamics_plot$variable == "biomass",]$plot %<>%
  map(., ~ .x + lims(y = bm_min_max, x = nb_year_min_max))

temporal_dynamics_plot %>%
  filter(variable == "bm_std", station %in% st_decrease_increase_rigal_biomass$station) %>%
  plot_grid(plotlist = .$plot, ncol = 3, labels = st_decrease_increase_rigal_biomass$station)
```

## Station grouping

### Rigal station increase / decrease

Les stations ont moins de 40 kilos au départ ont l'air comparable en terme de
dynamique.

```{r, eval=FALSE}
loadd(biomass_group)

p_rigal_decrease_increase_slope_st <- 
  st_decrease_increase_rigal_biomass %>%
  left_join(biomass_group, by = "station") %>%
  ggplot(aes(y = linear_slope, x = value, color = shape_class)) +
  geom_point() +
  facet_wrap(~variable)
p_rigal_decrease_increase_slope_st
```

### Tendancies in rigal increase / decrease 

```{r}
rigal_biomass_coeff_dynamics <- st_decrease_increase_rigal_biomass %>%
  select(station, linear_slope, strd_error) %>%
  left_join(temporal_dynamics_coef, by = "station") %>%
  filter(!coeff %in% get_biomass_var(), term == "slope") %>%
  select(station, coeff, estimate, std.error, linear_slope, bm_std_error = strd_error) %>%
  mutate(reg_weight = (abs(estimate / std.error) + abs(linear_slope / bm_std_error))/2)
rigal_biomass_coeff_dynamics %>%
  ggplot(aes(x = reg_weight)) +
  geom_histogram() +
  facet_wrap(~coeff)

rigal_biomass_coeff_dynamics %>%
  ggplot(aes(x = linear_slope, y = estimate, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~coeff, scales = "free_y")
rigal_biomass_coeff_dynamics %>%
  ggplot(aes(x = linear_slope, y = estimate, size = reg_weight)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~coeff, scales = "free_y")
```

### With group 

#### Median

```{r}
##Summary of group 
biomass_group %>%
  filter(group_type == "median") %>%
  ggplot(aes(x = bm)) +
  geom_histogram() +
  facet_wrap(bm_var~summary_type, scales = "free_x")

group_results <- 
  rigal_biomass_coeff_dynamics %>%
  left_join(biomass_group, by = "station") %>% 
  filter(group_type == "median", bm_var == "bm_std")

p1 <- group_results %>%
  filter(summary_type == "first_3_year") %>%
  ggplot(aes(x = linear_slope, y = estimate, color = group,
      size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y")

p3 <- group_results  %>%
  filter(summary_type == "median") %>%
  ggplot(aes(x = linear_slope, y = estimate, color = group, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y")


p1
p3
```

#### Little and big rivers

```{r}
loadd(stream_group)
#grandes/petites rivières
stream_group %>%
  ggplot(aes(x = width_river_mean, fill = group)) +
  geom_histogram() +
  facet_grid(~group_type)
  
stream_group %>%
  filter(group_type == "median") %>%
  ggplot(aes(x = width_river_mean, fill = protocol_type)) +
  geom_histogram()

stream_group %>%
  filter(group_type == "median") %>%
  left_join(
    biomass_group %>%
    filter(group_type == "median", summary_type == "median") %>%
    select(-group_type, -summary_type, -group),
  by = "station"
  ) %>%
  filter(!is.na(protocol_type)) %>%
  ggplot(aes(x = bm, fill = protocol_type)) +
  geom_histogram() +
  facet_wrap(~bm_var, scales = "free_x")
```

```{r}
group_results_stream_size <- 
  group_results %>%
  left_join(
    filter(stream_group, group_type == "median") %>%
      rename(stream_group = group) %>% select(-group_type)
    , by = "station")


group_results_stream_size %>%
  filter(summary_type == "first_3_year", linear_slope < 8) %>%
  ggplot(aes(x = linear_slope, y = estimate, color = protocol_type, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y") +
  labs(title = "Group as protocol type")

group_results_stream_size %>%
  filter(summary_type == "first_3_year", linear_slope < 8) %>%
  ggplot(aes(x = linear_slope, y = estimate, color = protocol_type, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y") +
  labs(title = "Group as mean river size")

group_results_stream_size %>%
  filter(summary_type == "first_3_year", linear_slope < 8) %>%
  ggplot(aes(x = linear_slope, y = estimate, color = group, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y") +
  labs(title = "Group as mean river size")

group_results_stream_size %>%
  filter(summary_type == "median", linear_slope < 8) %>%
  ggplot(aes(x = linear_slope, y = estimate, color = group, size = reg_weight, weight = reg_weight)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~coeff, scales = "free_y") +
  labs(title = "Group as mean biomass")
```

# Patterns

```{r}
loadd(bm_net_group)
loadd(log_bm_net_group)

bm_net_group %>%
  filter(!is.na(protocol_type)) %>%
  ggplot(aes(x = bm_slope, y = linear_slope, color = log(bm), size = reg_weight, weight = reg_weight)) +
  geom_point() +
  scale_color_viridis() +
  #geom_smooth(method = "lm") +
  facet_grid(variable~protocol_type, scales = "free") +
  labs(title = "Group as mean biomass")


```

# Correlation

```{r}
cor_bm_net <- bm_net_group %>%
  select(bm_slope, variable, linear_slope, bm, width_river_mean) %>%
  pivot_wider(names_from = variable, values_from = linear_slope) 
corrplot::corrplot(cor(na.omit(cor_bm_net)), type = "upper")

library(ade4)
library(factoextra)
res.pca <- dudi.pca(na.omit(cor_bm_net),
                    scannf = FALSE,   # Cacher le scree plot
                    nf = 3            # Nombre d'axes gardés
                    )
screeplot(res.pca, main = "Screeplot - Eigenvalues")
p1 <- fviz_pca_var(res.pca,
  col.var = "contrib", 
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = TRUE     
)
p2 <- fviz_pca_var(res.pca,
  axes = c(1, 3),
  col.var = "contrib", 
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = TRUE     
)

p3 <- fviz_pca_var(res.pca,
  axes = c(2, 3),
  col.var = "contrib", 
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
  repel = TRUE     
)
plot_grid(p1, p2, p3)
```

# Statistical models

## Raw bm

```{r, eval = FALSE}
model_int <- compute_my_lm_vs_net_model(bm_net_group, var_to_group = c("variable"))
model_vif <- get_vif(model_int, model_cols = c("mod3", "mod5",
    "mod6", "mod8", "mod9"))
model_vif %>%
  ggplot(aes(y = vif, x = term)) +
  geom_hline(yintercept = 10) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(model_type~variable)
```

```{r, eval = FALSE}
library(yhat)
test <- model_int$mod3[[1]]
CCData <- commonalityCoefficients(model_int$data[[1]],
  "linear_slope",
  list("bm_slope", "inc_f", "bm"), "F")
CCData

test_data <- model_int$data[[1]]
lm_test <- lm(
  formula = linear_slope ~ bm_slope*inc_f*bm,
  weights = reg_weight
)
test <- regr(lm_test)
```

### Effect of protocol type on the model validity 

```{r}
model_by_protocol <- compute_my_lm_vs_net_model(
  filter(bm_net_group, !is.na(protocol_type)),
  var_to_group = c("variable", "protocol_type"),
  #var_to_scale = c("log_bm") 
)
model_var <- tidyselect::vars_select(names(model_by_protocol), starts_with("mod"))
model_vif <- get_vif(model_by_protocol,
  model_cols = model_var)
protocol_vec <- model_vif$protocol_type %>% unique
p_vif_protocol <- map(protocol_vec, function (x) {
  model_vif %>%
    filter(protocol_type == x) %>%
    ggplot(aes(y= vif, x = term)) +
    geom_hline(yintercept = 10) +
    geom_bar(stat = "identity") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = paste0("Protocol type: ", x)) +
    facet_grid(model_type~variable, scales = "free_y")
  })
p_vif_protocol[[1]]
p_vif_protocol[[2]]
```
```{r}
bm_net_group %>%
  filter(variable == "connectance") %>%
  ggplot(aes(x = bm_slope, y = bm)) +
  geom_point()

```


### Current best model

$$
Y = \alpha + \beta_1D_b + \beta_2D_bI_b + \beta_3D_bI_bB
$$

```{r, eval = FALSE}
res_mod <- model_by_protocol %>%
  filter(protocol_type == "complete") %>%
  select(-data) %>%
  pivot_longer(cols = c(mod1:last_col()),
    names_to = "model", values_to = "model_obj") %>%
  mutate(
    resume = map(model_obj, summary),
    anova = map(model_obj, anova)
  )
```

```{r, eval = FALSE}
filter(res_mod, model == "mod_inc_bm")[["resume"]]
filter(res_mod, model == "mod_inc_bm")[["anova"]]

filter(res_mod, model == "mod_bm_inc")[["resume"]]
filter(res_mod, model == "mod_bm_inc")[["anova"]]
```

```{r, eval = FALSE}
pred <- res_mod %>%
  filter(model == "mod4") %>%
  mutate(
    pred = map(model_obj, ~ggpredict(.x,
	terms = c("bm_slope [-8, -6, -4,-3, -2, -1, -.5, -.01, .01, .5, 1, 2, 3, 4, 6]", "bm [quart2]"))),
    pred_df = map(pred, as_tibble),
    plot = map(pred, ~plot(.x, add.data = FALSE)),
    plot_data = map(pred, ~plot(.x, add.data = TRUE)),
    #myplot = map2(pred, data, ~plot_final_model(ggpred = .x, rawdata = .y))
  )
plot_grid(plotlist = pred$plot)
```


```{r, eval = FALSE}
res_mod7 %<>%
  mutate(
    pred7 = map(mod7, ~ggpredict(.x,
	terms = c("bm_slope [-8, -6, -4,-3, -2, -1, -.5, -.01, .01, .5, 1, 2, 3, 4, 6]", "bm [quart2]", "inc_f"))),
    pred7_df = map(pred7, as_tibble),
    plot = map(pred7, ~plot(.x, add.data = FALSE)),
    plot_data = map(pred7, ~plot(.x, add.data = TRUE)),
    myplot = map2(pred7, data, ~plot_final_model(ggpred = .x, rawdata = .y))
  )

#plot_final_model(model_int$pred5[[1]], model_int$data[[1]])
plot_grid(plotlist = res_mod7$plot, labels = res_mod7$variable)
plot_grid(plotlist = res_mod7$plot_data, labels = res_mod7$variable)

test <- model_int$data[[1]]
res_mod7$pred7_df[[1]]
test %>%
  ggplot(aes(x = bm_slope, y = linear_slope, weight = reg_weight, size = reg_weight)) +
  geom_smooth(method = "lm") +
  geom_point()

#pred_test <-
  #model_int$pred5_df[[1]] %>%
  #as_tibble %>%
  #rename(increasing = group, group = facet) %>%
  #filter(increasing == FALSE & x < 0 | increasing == TRUE & x > 0)

#p <- ggplot(pred_test, aes(x = x , y = predicted, color = group)) +
  #geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha =
    #.1) +
  #geom_line() +
  #geom_point(data = rename(test,
      #predicted = linear_slope, x = bm_slope),
    #aes(x = x, y = predicted),
    #inherit.aes = FALSE)
```




### Is the model valid with log_bm ?

```{r}
log_bm_net_group %>%
  filter(!is.na(protocol_type)) %>%
  ggplot(aes(x = bm_slope, y = linear_slope, color = log(bm), size = reg_weight, weight = reg_weight)) +
  geom_point() +
  scale_color_viridis() +
  #geom_smooth(method = "lm") +
  facet_grid(variable~protocol_type, scales = "free") +
  labs(title = "Log biomass")

log_bm_net_group %>%
  filter(variable == "connectance") %>%
  ggplot(aes(x = bm_slope, y = bm)) +
  geom_point()
```


```{r}
loadd(log_bm_net_group)
model_log <- compute_my_lm_vs_net_model(
  log_bm_net_group, var_to_group = c("variable"),
)

model_var <- tidyselect::vars_select(names(model_by_protocol), starts_with("mod"))
model_log_vif <- get_vif(model_log, model_cols = model_var)

model_log_vif %>%
  ggplot(aes(y= vif, x = term)) +
  geom_hline(yintercept = 10) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(model_type~variable)
```

```{r}
model_by_protocol <- compute_my_lm_vs_net_model(
  filter(log_bm_net_group, !is.na(protocol_type)),
  var_to_group = c("variable", "protocol_type")
)

model_var <- tidyselect::vars_select(names(model_by_protocol), starts_with("mod"))
model_vif <- get_vif(model_by_protocol,
  model_cols = model_var)

protocol_vec <- model_vif$protocol_type %>% unique
p_vif_protocol <- map(protocol_vec, function (x) {
  model_vif %>%
    filter(protocol_type == x) %>%
    ggplot(aes(y= vif, x = term)) +
    geom_hline(yintercept = 10) +
    geom_bar(stat = "identity") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = paste0("Protocol type: ", x)) +
    facet_grid(model_type~variable, scales = "free_y")
  })
p_vif_protocol[[1]]
p_vif_protocol[[2]]
```

```{r}
res_mod <- model_by_protocol %>%
  filter(protocol_type == "complete") %>%
  select(-data) %>%
  pivot_longer(cols = all_of(model_var),
    names_to = "model", values_to = "model_obj") %>%
  mutate(
    resume = map(model_obj, summary),
    anova = map(model_obj, anova)
  )
```

```{r}
filter(res_mod, model == "mod_inc_log_bm")[["resume"]]
filter(res_mod, model == "mod_inc_log_bm")[["anova"]]
```

```{r}
filter(res_mod, model == "mod_log_bm_inc")[["resume"]]
filter(res_mod, model == "mod_log_bm_inc")[["anova"]]
```


```{r, eval = FALSE}
pred <- res_mod %>%
  filter(model == "mod4") %>%
  mutate(
    pred = map(model_obj, ~ggpredict(.x,
	terms = c("bm_slope [-8, -6, -4,-3, -2, -1, -.5, -.01, .01, .5, 1, 2, 3, 4, 6]", "bm [quart2]"))),
    pred_df = map(pred, as_tibble),
    plot = map(pred, ~plot(.x, add.data = FALSE)),
    plot_data = map(pred, ~plot(.x, add.data = TRUE)),
  )
plot_grid(plotlist = pred$plot)
```


### Can we predict the model without all simple effects?  

```{r, eval = FALSE}
# Perform a valid model 
pred <- model_int %>%
  select(-data, -mod4) %>%
  pivot_longer(cols = c(mod1:mod5), names_to = "model_type", values_to =
    "mod_obj") %>%
  mutate(
    pred_ref = map2(mod_obj, model_type, function (x, y) {
       if (y %in% c("mod3", "mod5"))
	 terms_spec <- c("bm_slope", "inc_f", "bm")
       else
	 terms_spec <- c("bm_slope", "inc_f", "bm_group") 
      ggpredict(x, terms = terms_spec)
      }
    ),
    pred_cte = map2(mod_obj, model_type, function (x, y) {
       if (y %in% c("mod3", "mod5"))
	 terms_spec <- c("linear_slope", "inc_f", "bm")
       else
	 terms_spec <- c("linear_slope", "inc_f", "bm_group") 
      ggeffect(x, terms = terms_spec)
      }
    )
  )

pred %<>%
  mutate(
  plot_pred_ref = map(pred_ref, plot, add.data = TRUE),
  plot_pred_cte = map(pred_cte, plot, add.data = TRUE)
  )
pred_richness <- pred %>%
  filter(variable == "richness", model_type == "mod3")

pred$plot_pred_ref[[1]]
pred$plot_pred_cte[[1]]
pred$plot_pred[[2]]
pred$plot_pred[[3]]
pred$plot_pred_ref[[4]]
```


```{r, eval = FALSE}
library(ggeffects)
mydf <- ggpredict(model_int$mod3[[1]], terms = c("linear_slope", "inc_f",
    "bm"))
plot(mydf, add.data = TRUE)

```

```{r, eval = FALSE}
model_log %<>%
  mutate(
    pred5 = map(mod3, ~ggpredict(.x,
	terms = c("linear_slope [-8, -6, -4,-3, -2, -1, -.5, -.01, .01, .5, 1, 2, 3, 4, 6]", "inc_f", "bm"))),
    pred5_df = map(pred5, as_tibble),
    plot = map(pred5, ~plot(.x, add.data = TRUE)),
    myplot = map2(pred5, data, ~plot_final_model(ggpred = .x, rawdata = .y))
  )

#plot_final_model(model_int$pred5[[1]], model_int$data[[1]])
plot_grid(plotlist = model_int$plot, labels = model_int$variable)
model_int$plot[[1]]
summary(model_int$mod3[[1]])
test <- model_int$data[[1]]
model_int$pred5_df[[1]]
test %>%
  ggplot(aes(x = bm_slope, y = linear_slope, weight = reg_weight, size = reg_weight)) +
  geom_smooth(method = "lm") +
  geom_point()

pred_test <-
  model_int$pred5_df[[1]] %>%
  as_tibble %>%
  rename(increasing = group, group = facet) %>%
  filter(increasing == FALSE & x < 0 | increasing == TRUE & x > 0)

p <- ggplot(pred_test, aes(x = x , y = predicted, color = group)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha =
    .1) +
  geom_line() +
  geom_point(data = rename(test,
      predicted = linear_slope, x = bm_slope),
    aes(x = x, y = predicted),
    inherit.aes = FALSE)
```

```{r, eval = FALSE}
model_int$pred5_df[[1]] %>%
  ggplot()

plot_final_model(model_int$pred5[[1]], rawdata = model_int$data[[1]], facet =
  TRUE)
```


```{r, eval = FALSE}
library(segmented)

mod_tlvl <- lm(estimate ~ linear_slope, model_int$data[[2]])
mod_tlvl <- lm(
  estimate ~ linear_slope*decreasing*group,#(linear_slope < 0)*linear_slope + (linear_slope >= 0)*linear_slope,
  mutate(model_int$data[[2]], decreasing = linear_slope < 0)
)
seg_tlvl <- segmented(mod_tlvl, seg.Z=~linear_slope)
plot(seg_tlvl)

mod_richness <- lm(estimate ~ linear_slope, model_int$data[[2]])
test <- segmented(mod_richness, seg.Z=~linear_slope)
plot(test)

car::vif(test)
```


## Richness

```{r}
knitr::opts_chunk$set(
  eval = FALSE 
)
```


```{r}
st_big_bm_tendancies <- group_results %>%
  filter(abs(linear_slope) > 5000) %>%
  .$station %>%
  unique
plot_big_bm_tendancies <- temporal_dynamics_plot %>%
  filter(variable == "biomass", station %in% st_big_bm_tendancies) %>%
  .$plot
plot_grid(
  plotlist = map(plot_big_bm_tendancies, 
    ~.x + lims(x = c(0, 10), y = c(0, 155000)))
)
```


```{r}
rigal_shape_var <- rigal_classification %>%
  unnest(classif) %>%
  select(station, variable, shape_class) %>%
  mutate(station = as.character(station))

rigal_shape_var %>%
  filter(station %in% st_decrease_increase_rigal_biomass$station) %>%
  ggplot(aes(x = shape_class)) +
  geom_bar() +
  facet_wrap(~ variable) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}

```


## SAX

```{r, eval = FALSE}
library(jmotif)
loadd(full_data2)
sax_all_variable <- full_data2 %>%
  select(station, nb_year, biomass:log_bm) %>%
  pivot_longer(cols = biomass:log_bm, names_to = "variable", values_to = "value") %>%
  group_by(station, variable) %>%
  arrange(nb_year) %>%
  nest() %>%
  mutate(
    zts = map(data, function(x) znorm(x$value, threshold = 0.01)),
    paa = map(zts, ~paa(., 3)),
    sax = map_chr(paa, ~series_to_string(., 3))
  ) %>%
  ungroup()

# CBA:
sax_all_variable %>%
  filter(station %in% cba_rigal_sax$station, !variable %in% c("biomass", "nbnode")) %>%
  ggplot(aes(x = sax)) +
  geom_bar() +
  facet_wrap(facets = ~variable)

sax_all_variable %>%
  filter(
    station %in% cba_rigal_sax$station,
    !variable %in% c("biomass", "nbnode")
    ) %>%
  ggplot(aes(x = sax)) +
  geom_bar() +
  facet_wrap(facets = ~variable)

```

